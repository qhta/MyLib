<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Qhta.WPF.Utils</name>
    </assembly>
    <members>
        <member name="F:Qhta.WPF.Utils.ClipboardUtils.Header">
            <summary>      
            The string contains index references to  other spots in the string, so we need placeholders so we can compute the  offsets. <br/>      
            The  <![CDATA[<<<<<<<]]>_ strings are just placeholders.  We'll back-patch them actual values afterwards. <br/>      
            The string layout  (<![CDATA[<<<]]>) also ensures that it can't appear in the body  of the html because the <![CDATA[<]]> <br/>      
            character must be escaped. <br/>      
            </summary>      
        </member>
        <member name="F:Qhta.WPF.Utils.ClipboardUtils.StartFragment">
            <summary>      
            html comment to point the beginning of  html fragment      
            </summary>      
        </member>
        <member name="F:Qhta.WPF.Utils.ClipboardUtils.EndFragment">
            <summary>      
            html comment to point the end of html  fragment      
            </summary>      
        </member>
        <member name="F:Qhta.WPF.Utils.ClipboardUtils._byteCount">
            <summary>      
            Used to calculate characters byte count  in UTF-8      
            </summary>      
        </member>
        <member name="M:Qhta.WPF.Utils.ClipboardUtils.CreateHtmlDataObject(System.String,System.String)">
            <summary>      
            Create <see  cref="T:System.Windows.DataObject"/> with given html and plain-text ready to be  used for clipboard or drag and drop.<br/>      
            Handle missing  <![CDATA[<html>]]> tags, specified startend segments and Unicode  characters.      
            </summary>      
            <remarks>      
            <para>      
            Windows Clipboard works with UTF-8  Unicode encoding while .NET strings use with UTF-16 so for clipboard to  correctly      
            decode Unicode string added to it from  .NET we needs to be re-encoded it using UTF-8 encoding.      
            </para>      
            <para>      
            Builds the CF_HTML header correctly for  all possible HTMLs<br/>      
            If given html contains start/end  fragments then it will use them in the header:      
             <code><![CDATA[<html><body><!--StartFragment-->hello  <b>world</b><!--EndFragment--></body></html>]]></code>      
            If given html contains html/body tags  then it will inject start/end fragments to exclude html/body tags:      
             <code><![CDATA[<html><body>hello  <b>world</b></body></html>]]></code>      
            If given html doesn't contain html/body  tags then it will inject the tags and start/end fragments properly:      
            <code><![CDATA[hello  <b>world</b>]]></code>      
            In all cases creating a proper CF_HTML  header:<br/>      
            <code>      
            <![CDATA[      
            Version:1.0      
            StartHTML:000000177      
            EndHTML:000000329      
            StartFragment:000000277      
            EndFragment:000000295      
            StartSelection:000000277      
            EndSelection:000000277      
            <!DOCTYPE HTML PUBLIC  "-//W3C//DTD HTML 4.0 Transitional//EN">      
             <html><body><!--StartFragment-->hello  <b>world</b><!--EndFragment--></body></html>      
            ]]>      
            </code>      
            See format specification here: [http://msdn.microsoft.com/library/default.asp?url=/workshop/networking/clipboard/htmlclipboard.asp][9]      
            </para>      
            </remarks>      
            <param name="html">a  html fragment</param>      
            <param  name="plainText">the plain text</param>      
        </member>
        <member name="M:Qhta.WPF.Utils.ClipboardUtils.CopyToClipboard(System.String,System.String)">
            <summary>      
            Clears clipboard and sets the given  HTML and plain text fragment to the clipboard, providing additional  meta-information for HTML.<br/>      
            See <see  cref="M:Qhta.WPF.Utils.ClipboardUtils.CreateHtmlDataObject(System.String,System.String)"/> for HTML fragment details.<br/>      
            </summary>      
            <example>      
             ClipboardHelper.CopyToClipboard("Hello <b>World</b>",  "Hello World");      
            </example>      
            <param name="html">a  html fragment</param>      
            <param  name="plainText">the plain text</param>      
        </member>
        <member name="M:Qhta.WPF.Utils.ClipboardUtils.GetHtmlDataString(System.String)">
            <summary>      
            Generate HTML fragment data string with  header that is required for the clipboard.      
            </summary>      
            <param name="html">the  html to generate for</param>      
            <returns>the resulted  string</returns>      
        </member>
        <member name="M:Qhta.WPF.Utils.ClipboardUtils.GetByteCount(System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>      
            Calculates the number of bytes produced  by encoding the string in the string builder in UTF-8 and not .NET default  string encoding.      
            </summary>      
            <param name="sb">the  string builder to count its string</param>      
            <param  name="start">optional: the start index to calculate from (default  - start of string)</param>      
            <param  name="end">optional: the end index to calculate to (default - end  of string)</param>      
            <returns>the number of bytes  required to encode the string in UTF-8</returns>      
        </member>
        <member name="P:Qhta.WPF.Utils.ColorAdjustEffect.Saturation">
            <summary>A value between 0 and 1 to alter the amount of colour left in the image. 0 is entirely greyscale, and 1 is unaffected. Default is 1.</summary>
        </member>
        <member name="P:Qhta.WPF.Utils.ColorAdjustEffect.Gamma">
            <summary>A value between 0 and 1 to alter the lightness of the greyscale without altering true black or true white. 
            0 shifts shades closer to true black, and 1 shifts shades closer to true white. Default is 0.5.</summary>
        </member>
        <member name="P:Qhta.WPF.Utils.ColorAdjustEffect.BrightnessAdjustment">
            <summary>A value between -1 and 1 to linearly move the end result closer to true black or true white respectively.
            -1 will result in an entirely black image, +1 will result in an entirely white image. Default is 0.</summary>
        </member>
        <member name="P:Qhta.WPF.Utils.ColorAdjustEffect.RedAdjustment">
            <summary>A value between -1 and 1 to linearly increase the Red component of the result.
            -1 will remove all Red from the image, +1 will maximize all Red in the image. Default is 0.</summary>
        </member>
        <member name="P:Qhta.WPF.Utils.ColorAdjustEffect.GreenAdjustment">
            <summary>A value between -1 and 1 to linearly increase the Green component of the result.
            -1 will remove all Green from the image, +1 will maximize all Green in the image. Default is 0.</summary>
        </member>
        <member name="P:Qhta.WPF.Utils.ColorAdjustEffect.BlueAdjustment">
            <summary>A value between -1 and 1 to linearly increase the Blue component of the result.
            -1 will remove all Blue from the image, +1 will maximize all Blue in the image. Default is 0.</summary>
        </member>
        <member name="T:Qhta.WPF.Utils.ComboBoxBehavior">
            <summary>
            ComboBoxBehavior
            </summary>
        </member>
        <member name="M:Qhta.WPF.Utils.ComboBoxBehavior.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Qhta.WPF.Utils.BitSetConverter" -->
        <!-- Badly formed XML comment ignored for member "T:Qhta.WPF.Utils.BitTestConverter" -->
        <member name="T:Qhta.WPF.Utils.BoolToVisibilityConverter">
            <summary>
            One way value converter bool => Visibility (Visible, Collapsed)
            </summary>
        </member>
        <member name="T:Qhta.WPF.Utils.CamelStringConverter">
            <summary>
            String value converter between "camel string" and "CamelString"
            </summary>
        </member>
        <member name="M:Qhta.WPF.Utils.CamelStringConverter.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <summary>
            Convert from "camel string" to "CamelString"
            </summary>
            <param name="value"></param>
            <param name="targetType"></param>
            <param name="parameter"></param>
            <param name="culture"></param>
            <returns></returns>
        </member>
        <member name="M:Qhta.WPF.Utils.CamelStringConverter.ConvertBack(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <summary>
            Convert from "CamelString" to "camel string"
            </summary>
            <param name="value"></param>
            <param name="targetType"></param>
            <param name="parameter"></param>
            <param name="culture"></param>
            <returns></returns>
        </member>
        <member name="T:Qhta.WPF.Utils.EnumValue">
            <summary>
            Obiekt zastępujący wartość wyliczeniową do wyświetlania narodowych nazw w listach wyboru
            </summary>
        </member>
        <member name="P:Qhta.WPF.Utils.EnumValue.Value">
            <summary>
            Wartość (przeliczona na int)
            </summary>
        </member>
        <member name="P:Qhta.WPF.Utils.EnumValue.Name">
            <summary>
            Nazwa wyświetlana
            </summary>
        </member>
        <member name="M:Qhta.WPF.Utils.EnumValue.ToString">
            <summary>
            Konwersja na łańcuch bierze nazwę
            </summary>
            <returns></returns>
        </member>
        <member name="T:Qhta.WPF.Utils.EnumValueConverter">
            <summary>
            Konwerter wartości wyliczeniowej.  
            Zamienia wartość wyliczeniową na liczbową zgodnie z podaną listą wartości.
            Umożliwia wyświetlanie listy wartości w językach narodowych
            </summary>
        </member>
        <member name="P:Qhta.WPF.Utils.EnumValueConverter.EnumValues">
            <summary>
            Wartości wyliczeniowe. Mogą być ustawione w pliku XAML
            </summary>
        </member>
        <member name="P:Qhta.WPF.Utils.EnumValueConverter.EnumType">
            <summary>
            Typ wyliczeniowy. Określa listę wartości wyliczeniowych
            </summary>
        </member>
        <member name="M:Qhta.WPF.Utils.EnumValueConverter.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <summary>
            Konwersja wprost - identyczna jak konwersja wstecz.
            Kierunek konwersji rozpoznawany przez parametr <c>targetType</c>
            </summary>
        </member>
        <member name="M:Qhta.WPF.Utils.EnumValueConverter.ConvertBack(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <summary>
            Konwersja wstecz - identyczna jak konwersja wprost.
            Kierunek konwersji rozpoznawany przez parametr <c>targetType</c>
            </summary>
        </member>
        <member name="M:Qhta.WPF.Utils.EnumValueConverter.ConvertToEnum(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <summary>
            Konwersja łańcucha, wartości logicznej lub liczby na wartość wyliczeniową
            </summary>
        </member>
        <member name="M:Qhta.WPF.Utils.EnumValueConverter.Cast``1(System.Object)">
            <summary>
            Pomocnicza procedura do rzutowania na wybrany typ
            </summary>
            <typeparam name="T"></typeparam>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:Qhta.WPF.Utils.EnumValueConverter.ConvertFromEnum(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <summary>
            Konwersja wartości wyliczeniowej na liczbową
            </summary>
        </member>
        <member name="M:Qhta.WPF.Utils.EnumValueConverter.InitEnumValues">
            <summary>
            Inicjacja listy wartości z typu wyliczeniowego
            </summary>
        </member>
        <member name="T:Qhta.WPF.Utils.EqualityComparingConverter">
            <summary>
            Konwerter porównujący wartość z parametrem. Wynikiem jest boolean
            </summary>
        </member>
        <member name="M:Qhta.WPF.Utils.EqualityComparingConverter.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <summary>
            Konwersja wprost
            </summary>
        </member>
        <member name="M:Qhta.WPF.Utils.EqualityComparingConverter.ConvertBack(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <summary>
            Konwersja wstecz
            </summary>
        </member>
        <member name="T:Qhta.WPF.Utils.InverseValueConverter">
            <summary>
            Konwerter wartości liczbowej na jej odwrotność
            </summary>
        </member>
        <member name="M:Qhta.WPF.Utils.InverseValueConverter.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <summary>
            Konwersja wprost
            </summary>
        </member>
        <member name="M:Qhta.WPF.Utils.InverseValueConverter.ConvertBack(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <summary>
            Konwersja wstecz
            </summary>
        </member>
        <member name="M:Qhta.WPF.Utils.InverseValueConverter.DoConvert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <summary>
            Właściwa procedura konwersji
            </summary>
        </member>
        <member name="T:Qhta.WPF.Utils.TypeNameConverter">
            <summary>
            Konwerter nazwy typu
            </summary>
        </member>
        <member name="T:Qhta.WPF.Utils.DataGridBehavior">
            <summary>
            Collection of DataGrid behavior
            </summary>
        </member>
        <member name="T:Qhta.WPF.Utils.DynamicTemplateSelector">
            <summary>
            Provides a means to specify DataTemplates to be selected from within WPF code
            </summary>
        </member>
        <member name="F:Qhta.WPF.Utils.DynamicTemplateSelector.TemplatesProperty">
            <summary>
            Generic attached property specifying <see cref="T:Qhta.WPF.Utils.Template"/>s
            used by the <see cref="T:Qhta.WPF.Utils.DynamicTemplateSelector"/>
            </summary>
            <remarks>
            This attached property will allow you to set the templates you wish to be available whenever
            a control's TemplateSelector is set to an instance of <see cref="T:Qhta.WPF.Utils.DynamicTemplateSelector"/>
            </remarks>
        </member>
        <member name="M:Qhta.WPF.Utils.DynamicTemplateSelector.GetTemplates(System.Windows.UIElement)">
            <summary>
            Gets the value of the <paramref name="element"/>'s attached <see cref="F:Qhta.WPF.Utils.DynamicTemplateSelector.TemplatesProperty"/>
            </summary>
            <param name="element">The <see cref="T:System.Windows.UIElement"/> who's attached template's property you wish to retrieve</param>
            <returns>The templates used by the givem <paramref name="element"/>
            when using the <see cref="T:Qhta.WPF.Utils.DynamicTemplateSelector"/></returns>
        </member>
        <member name="M:Qhta.WPF.Utils.DynamicTemplateSelector.SetTemplates(System.Windows.UIElement,Qhta.WPF.Utils.TemplateCollection)">
            <summary>
            Sets the value of the <paramref name="element"/>'s attached <see cref="F:Qhta.WPF.Utils.DynamicTemplateSelector.TemplatesProperty"/>
            </summary>
            <param name="element">The element to set the property on</param>
            <param name="collection">The collection of <see cref="T:Qhta.WPF.Utils.Template"/>s to apply to this element</param>
        </member>
        <member name="M:Qhta.WPF.Utils.DynamicTemplateSelector.SelectTemplate(System.Object,System.Windows.DependencyObject)">
            <summary>
            Overriden base method to allow the selection of the correct DataTemplate
            </summary>
            <param name="item">The item for which the template should be retrieved</param>
            <param name="container">The object containing the current item</param>
            <returns>The <see cref="T:System.Windows.DataTemplate"/> to use when rendering the <paramref name="item"/></returns>
        </member>
        <member name="T:Qhta.WPF.Utils.TemplateCollection">
            <summary>
            Holds a collection of <see cref="T:Qhta.WPF.Utils.Template"/> items
            for application as a control's DataTemplate.
            </summary>
        </member>
        <member name="T:Qhta.WPF.Utils.Template">
            <summary>
            Provides a link between a value and a <see cref="P:Qhta.WPF.Utils.Template.DataTemplate"/>
            for the <see cref="T:Qhta.WPF.Utils.DynamicTemplateSelector"/>
            </summary>
            <remarks>
            In this case, our value is a <see cref="T:System.Type"/> which we are attempting to match
            to a <see cref="P:Qhta.WPF.Utils.Template.DataTemplate"/>
            </remarks>
        </member>
        <member name="F:Qhta.WPF.Utils.Template.ValueProperty">
            <summary>
            Provides the value used to match this <see cref="P:Qhta.WPF.Utils.Template.DataTemplate"/> to an item
            </summary>
        </member>
        <member name="F:Qhta.WPF.Utils.Template.DataTemplateProperty">
            <summary>
            Provides the <see cref="P:Qhta.WPF.Utils.Template.DataTemplate"/> used to render items matching the <see cref="P:Qhta.WPF.Utils.Template.DataType"/>
            </summary>
        </member>
        <member name="P:Qhta.WPF.Utils.Template.DataType">
            <summary>
            Gets or Sets the value used to match this <see cref="P:Qhta.WPF.Utils.Template.DataTemplate"/> to an item
            </summary>
        </member>
        <member name="P:Qhta.WPF.Utils.Template.DataTemplate">
            <summary>
            Gets or Sets the <see cref="P:Qhta.WPF.Utils.Template.DataTemplate"/> used to render items matching the <see cref="P:Qhta.WPF.Utils.Template.DataType"/>
            </summary>
        </member>
        <member name="M:Qhta.WPF.Utils.GeometryUtils.Angle(System.Windows.Point,System.Windows.Point)">
            <summary>
            Kąt punktu w biegunowym układzie współrzędnych
            </summary>
            <param name="p">wejściowy punkt</param>
            <param name="center">Środek układu współrzędnych</param>
            <returns></returns>
        </member>
        <member name="M:Qhta.WPF.Utils.GeometryUtils.Radius(System.Windows.Point,System.Windows.Point)">
            <summary>
            Odległość punktu od środka układu współrzędnych
            </summary>
            <param name="p">wejściowy punkt</param>
            <param name="center">Środek układu współrzędnych</param>
            <returns></returns>
        </member>
        <member name="M:Qhta.WPF.Utils.GeometryUtils.Move(System.Windows.Point,System.Windows.Point,System.Double)">
            <summary>
            Przesunięcie współrzędnych punktu radialnie wzlędem środka o pewną odległość
            </summary>
            <param name="p">Przesuwany punkt</param>
            <param name="center">Środek układu współrzędnych</param>
            <param name="M">Odległość przesunięcia. 
            Wartość dodatnia oznacza zwiększenie, ujemna - zmniejszenie odległości od środka</param>
            <returns></returns>
        </member>
        <member name="M:Qhta.WPF.Utils.GeometryUtils.Rotate(System.Windows.Point,System.Windows.Point,System.Double)">
            <summary>
            Przesunięcie współrzędnych punktu po okręgu względem środka o pewien kąt
            </summary>
            <param name="p">Przesuwany punkt</param>
            <param name="center">Środek układu współrzędnych</param>
            <param name="A">Kąt obrotu. 
            Wartość dodatnia oznacza zwiększenie, ujemna - zmniejszenie odległości od środka</param>
            <returns></returns>
        </member>
        <member name="M:Qhta.WPF.Utils.GeometryUtils.GetOverlappingGeometry(System.Windows.Media.Geometry)">
            <summary>
            Utworzenie z geometrii nakładających się obszarów.
            </summary>
            <param name="geometry">geometria wejściowa</param>
            <returns></returns>
        </member>
        <member name="M:Qhta.WPF.Utils.GridViewBehavior.RegisterColumn(System.Windows.Controls.GridViewColumn,System.Windows.Controls.ListView)">
            <summary>
            Registering columns needed as there is no backward relationship between GridViewColumn an its parent ListView
            </summary>
            <param name="column"></param>
            <param name="listView"></param>
        </member>
        <member name="M:Qhta.WPF.Utils.ListBoxBehavior.GetMoveItemsEnabled(System.Windows.DependencyObject)">
            <summary>
              MoveItemsEnabled behavior allows ListBoxItems to be drag and drop inside list with mouse.
            </summary>
        </member>
        <member name="M:Qhta.WPF.Utils.ListBoxBehavior.SetMoveItemsEnabled(System.Windows.DependencyObject,System.Boolean)">
            <summary>
              For MoveItemsEnabled behavior list view items source should implement IListSelector interface.
            </summary>
        </member>
        <member name="F:Qhta.WPF.Utils.ListBoxBehavior.MoveItemsEnabledProperty">
            <summary>
              For MoveItemsEnabled behavior list view items source should implement IListSelector interface.
            </summary>
        </member>
        <member name="T:Qhta.WPF.Utils.ListViewBehavior">
            <summary>
            Collection of ListView behavior
            </summary>
        </member>
        <member name="M:Qhta.WPF.Utils.ListViewBehavior.RegisterColumn(System.Windows.Controls.GridViewColumn,System.Windows.Controls.ListView)">
            <summary>
            Registering columns needed as there is no backward relationship between GridViewColumn an its parent ListView
            </summary>
            <param name="column"></param>
            <param name="listView"></param>
        </member>
        <member name="M:Qhta.WPF.Utils.ListViewBehavior.GetMultiSelect(System.Windows.DependencyObject)">
            <summary>
              For MultiSelect behavior list view items source should implement IListSelector interface.
            </summary>
        </member>
        <member name="M:Qhta.WPF.Utils.ListViewBehavior.SetMultiSelect(System.Windows.DependencyObject,System.Boolean)">
            <summary>
              For MultiSelect behavior list view items source should implement IListSelector interface.
            </summary>
        </member>
        <member name="F:Qhta.WPF.Utils.ListViewBehavior.MultiSelectProperty">
            <summary>
              For MultiSelect behavior list view items source should implement IListSelector interface.
            </summary>
        </member>
        <member name="T:Qhta.WPF.Utils.ListViewCustomizableCellPresenter">
            <summary>
            Class allows for reseting hard coded ListViewItem margins and paddings
            </summary>
        </member>
        <member name="F:Qhta.WPF.Utils.ListViewCustomizableCellPresenter.PaddingProperty">
            <summary>
            Padding dependency property registration
            </summary>
        </member>
        <member name="P:Qhta.WPF.Utils.ListViewCustomizableCellPresenter.Padding">
            <summary>
            Padding dependency property
            </summary>
        </member>
        <member name="M:Qhta.WPF.Utils.ProgressMonitor`1.#ctor(System.Windows.DependencyObject,System.Windows.DependencyProperty,System.Int32)">
            <summary>
            Create for value only update.
            </summary>
            <param name="object">DependencyObject to be updated on Report</param>
            <param name="valueProperty">DependencyProperty of DependencyObject to be updated</param>
            <param name="updatePeriod">updatePeriod in milliseconds</param>
        </member>
        <member name="M:Qhta.WPF.Utils.ProgressMonitor`1.#ctor(System.Windows.DependencyObject,System.Windows.DependencyProperty,System.Windows.DependencyProperty,System.Int32)">
            <summary>
            Create for maximum and current value update.
            </summary>
            <param name="object">DependencyObject to be updated</param>
            <param name="valueProperty">DependencyProperty of DependencyObject to be updated on Report</param>
            <param name="maxProperty">DependencyProperty of DependencyObject to be updated on SetMaximum</param>
            <param name="updatePeriod">updatePeriod in milliseconds (apply to valueProperty only)</param>
        </member>
        <member name="T:Qhta.WPF.Utils.TimingMessageBox">
            <summary>
            TimingMessageBox
            </summary>
        </member>
        <member name="M:Qhta.WPF.Utils.TimingMessageBox.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="M:Qhta.WPF.Utils.ToolTipBehavior.GetActiveToolTipEnabled(System.Windows.DependencyObject)">
            <summary>
              ActiveToolTipEnabled behavior allows ToolTip Popup to contain active hyperlinks
            </summary>
        </member>
        <member name="M:Qhta.WPF.Utils.ToolTipBehavior.SetActiveToolTipEnabled(System.Windows.DependencyObject,System.Boolean)">
            <summary>
              ActiveToolTipEnabled behavior allows ToolTip Popup to contain active hyperlinks
            </summary>
        </member>
        <member name="F:Qhta.WPF.Utils.ToolTipBehavior.ActiveToolTipEnabledProperty">
            <summary>
              Dependency property for ActiveToolTipEnabled
            </summary>
        </member>
        <member name="M:Qhta.WPF.Utils.TreeViewBehavior.TreeViewSelectedItemBehavior.GetTreeViewItem(System.Windows.Controls.ItemsControl,System.Object)">
            <summary>
              Recursively search for an item in this subtree.
            </summary>
            <param name="container">
              The parent ItemsControl. This can be a TreeView or a TreeViewItem.
            </param>
            <param name="obj">
              The object to search item for.
            </param>
            <returns>
              The TreeViewItem that DataContext is the specified object.
            </returns>
        </member>
        <member name="M:Qhta.WPF.Utils.TreeViewBehavior.GetMultiSelect(System.Windows.DependencyObject)">
            <summary>
            For MultiSelect behavior not only tree view items source should implement IListSelector interface, 
            but also all tree view item items sources.
            </summary>
        </member>
        <member name="M:Qhta.WPF.Utils.TreeViewBehavior.SetMultiSelect(System.Windows.DependencyObject,System.Boolean)">
            <summary>
            For MultiSelect behavior not only tree view items source should implement IListSelector interface, 
            but also all tree view item items sources.
            </summary>
        </member>
        <member name="F:Qhta.WPF.Utils.TreeViewBehavior.MultiSelectProperty">
            <summary>
            For MultiSelect behavior not only tree view items source should implement IListSelector interface, 
            but also all tree view item items sources.
            </summary>
        </member>
        <member name="M:Qhta.WPF.Utils.TreeViewHelper.SetItemHierarchyVisible(System.Windows.Controls.TreeView,System.Collections.Generic.IEnumerable{System.Object},Qhta.WPF.Utils.TreeViewHelper.OnTreeViewVisible)">
            <summary>
            You cannot rely on this method to be synchronous. If you have any action that depend on the TreeViewItem 
            (last item of collectionOfRootToNodePath) to be visible, you should set it in the 'onTreeViewItemVisible' method.
            This method should work for Virtualized and non virtualized tree.
            The difference with ExpandItem is that this one open up the tree up to the target but will not expand the target itself,
            while ExpandItem expand the target itself.
            </summary>
            <param name="treeView">TreeView where  an item has to be set visible</param>
            <param name="listOfRootToNodePath">Any collectionic List. The collection should have every objet of the path to the targeted item from the root
            to the target. For example for an apple tree: AppleTree (index 0), Branch4, SubBranch3, Leaf2 (index 3)</param>
            <param name="onTreeViewVisible">Optionnal</param>
        </member>
        <member name="M:Qhta.WPF.Utils.TreeViewHelper.ExpandItem(System.Windows.Controls.TreeView,System.Collections.Generic.IEnumerable{System.Object},Qhta.WPF.Utils.TreeViewHelper.OnTreeViewVisible)">
            <summary>
            You cannot rely on this method to be synchronous. If you have any action that depend on the TreeViewItem 
            (last item of collectionOfRootToNodePath) to be visible, you should set it in the 'onTreeViewItemVisible' method.
            This method should work for Virtualized and non virtualized tree.
            The difference with SetItemHierarchyVisible is that this one open the target while SetItemHierarchyVisible does not try to expand the target.
            (SetItemHierarchyVisible just ensure the target will be visible)
            </summary>
            <param name="treeView">TreeView where  an item has to be set visible</param>
            <param name="listOfRootToNodePath">The collection should have every objet of the path, from the root to the targeted item.
            For example for an apple tree: AppleTree (index 0), Branch4, SubBranch3, Leaf2</param>
            <param name="onTreeViewVisible">Optionnal</param>
        </member>
        <member name="M:Qhta.WPF.Utils.TreeViewHelper.ExpandSubContainers(System.Windows.Controls.ItemsControl,System.Action{System.Windows.Controls.TreeViewItem,System.Object},Qhta.WPF.Utils.TreeViewHelper.ReferenceCounterTracker)">
            <summary>
            Expand any ItemsControl (TreeView, TreeViewItem, ListBox, ComboBox, ...) and their childs if any (TreeView)
            </summary>
            <param name="ic"></param>
            <param name="actionItemExpanded"></param>
            <param name="referenceCounterTracker"></param>
        </member>
        <member name="M:Qhta.WPF.Utils.TreeViewHelper.ExpandAll(System.Windows.Controls.TreeView,System.Action{System.Windows.Controls.TreeViewItem,System.Object},System.Action)">
            <summary>
            This method is asynchronous.
            Expand all items and subs recursively if any. Does support virtualization (item recycling).
            But honestly, make you a favor, make your life easier en create a model view around your hierarchy with
            a IsExpanded property for each node level and bind it to each TreeView node level.
            </summary>
            <param name="treeView"></param>
            <param name="actionItemExpanded"></param>
            <param name="actionAllItemExpanded"></param>
        </member>
        <member name="T:Qhta.WPF.Utils.TreeViewItemBehavior">
            <summary>
            Exposes attached behaviors that can be
            applied to TreeViewItem objects.
            </summary>
        </member>
        <member name="T:Qhta.WPF.Utils.TriggerTracing">
            <summary>
            Contains attached properties to activate Trigger Tracing on the specified Triggers.
            This file alone should be dropped into your app.
            </summary>
        </member>
        <member name="M:Qhta.WPF.Utils.TriggerTracing.GetTriggerName(System.Windows.TriggerBase)">
            <summary>
            Gets the trigger name for the specified trigger. This will be used
            to identify the trigger in the debug output.
            </summary>
            <param name="trigger">The trigger.</param>
            <returns></returns>
        </member>
        <member name="M:Qhta.WPF.Utils.TriggerTracing.SetTriggerName(System.Windows.TriggerBase,System.String)">
            <summary>
            Sets the trigger name for the specified trigger. This will be used
            to identify the trigger in the debug output.
            </summary>
            <param name="trigger">The trigger.</param>
            <returns></returns>
        </member>
        <member name="M:Qhta.WPF.Utils.TriggerTracing.GetTraceEnabled(System.Windows.TriggerBase)">
            <summary>
            Gets a value indication whether trace is enabled for the specified trigger.
            </summary>
            <param name="trigger">The trigger.</param>
            <returns></returns>
        </member>
        <member name="M:Qhta.WPF.Utils.TriggerTracing.SetTraceEnabled(System.Windows.TriggerBase,System.Boolean)">
            <summary>
            Sets a value specifying whether trace is enabled for the specified trigger
            </summary>
            <param name="trigger"></param>
            <param name="value"></param>
        </member>
        <member name="T:Qhta.WPF.Utils.TriggerTracing.TriggerTraceStoryboard">
            <summary>
            A dummy storyboard for tracing purposes
            </summary>
        </member>
        <member name="T:Qhta.WPF.Utils.TriggerTracing.TriggerTraceListener">
            <summary>
            A custom tracelistener.
            </summary>
        </member>
        <member name="T:Qhta.WPF.Utils.VisualTreeHelperExt">
            <summary>
            Extensions for VisualTreeHelper
            </summary>
        </member>
        <member name="T:XamlGeneratedNamespace.GeneratedInternalTypeHelper">
            <summary>
            GeneratedInternalTypeHelper
            </summary>
        </member>
        <member name="M:XamlGeneratedNamespace.GeneratedInternalTypeHelper.CreateInstance(System.Type,System.Globalization.CultureInfo)">
            <summary>
            CreateInstance
            </summary>
        </member>
        <member name="M:XamlGeneratedNamespace.GeneratedInternalTypeHelper.GetPropertyValue(System.Reflection.PropertyInfo,System.Object,System.Globalization.CultureInfo)">
            <summary>
            GetPropertyValue
            </summary>
        </member>
        <member name="M:XamlGeneratedNamespace.GeneratedInternalTypeHelper.SetPropertyValue(System.Reflection.PropertyInfo,System.Object,System.Object,System.Globalization.CultureInfo)">
            <summary>
            SetPropertyValue
            </summary>
        </member>
        <member name="M:XamlGeneratedNamespace.GeneratedInternalTypeHelper.CreateDelegate(System.Type,System.Object,System.String)">
            <summary>
            CreateDelegate
            </summary>
        </member>
        <member name="M:XamlGeneratedNamespace.GeneratedInternalTypeHelper.AddEventHandler(System.Reflection.EventInfo,System.Object,System.Delegate)">
            <summary>
            AddEventHandler
            </summary>
        </member>
    </members>
</doc>
